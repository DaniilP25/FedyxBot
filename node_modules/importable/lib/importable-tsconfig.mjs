import { resolve, dirname, sep } from 'node:path';

const generateHash = () => (`with-${Number(++__generateHashIncrement).toString(36)}`);
let __generateHashIncrement = 5e5;
const definePluginModuleFactory = Object;
const loadImportablePlugins = (importablePluginNames) => {
    const importablePlugins = __getImportablePlugins(importablePluginNames);
    return {
        testImportModuleSpecifier(importModuleSpecifier) {
            return importablePlugins.some(importablePlugin => importablePlugin.testImportModuleSpecifier(importModuleSpecifier));
        },
        testImportAttributes(importAttributes) {
            return importablePlugins.some(importablePlugin => importablePlugin.testImportAttributes(importAttributes));
        },
        generateTypeScriptDefinition(importModuleSpecifier, importAttributes, code) {
            const importablePlugin = importablePlugins.find(importablePlugin => (importablePlugin.testImportModuleSpecifier(importModuleSpecifier) &&
                importablePlugin.testImportAttributes(importAttributes))) || defaultImportablePlugin;
            return importablePlugin.generateTypeScriptDefinition(importModuleSpecifier, importAttributes, code);
        },
    };
};
const __getImportablePlugins = (plugins) => asArray(plugins, []).reduce((plugins, plugin) => {
    try {
        const loadedPlugin = Object(require(plugin));
        plugins.push(loadedPlugin);
    }
    catch (error) {
        console.error(`COULD NOT LOAD PLUGIN: ${plugin}`);
        console.error(Object(error).message || error);
    }
    return plugins;
}, []);
const defaultImportablePlugin = {
    testImportModuleSpecifier(_importModuleSpecifier) {
        return false;
    },
    testImportAttributes(_importAttributes) {
        return false;
    },
    generateTypeScriptDefinition(_moduleName, _code) {
        return `export default null as never`;
    },
};
const asArray = (value, fallback = []) => Array.isArray(value) ? value : fallback;
const getImportAttributes = (assertClause) => asArray(Object(assertClause).elements).reduce((importAttributes, element) => {
    const name = element.name.text;
    const value = Object(element.value).text;
    importAttributes[name] = value;
    return importAttributes;
}, Object.create(null));

var importableTsconfig = definePluginModuleFactory((modules) => {
    const ts = modules.typescript;
    const assertionMap = Object.create(null);
    let importablePlugins;
    return {
        create(info) {
            const pluginsOptions = info.config;
            importablePlugins = loadImportablePlugins(pluginsOptions.plugins);
            const createModuleResolver = (containingFile) => (moduleName, assertClause) => {
                const resolvedFileName = resolve(dirname(containingFile), moduleName);
                const importAttributes = getImportAttributes(assertClause);
                if (importablePlugins.testImportModuleSpecifier(resolvedFileName) &&
                    importablePlugins.testImportAttributes(importAttributes)) {
                    const moduleHash = generateHash();
                    const hashedFileName = `${sep}${moduleHash}${sep}..${resolvedFileName}`;
                    assertionMap[hashedFileName] = { resolvedFileName, importAttributes };
                    return {
                        extension: ts.Extension.Dts,
                        isExternalLibraryImport: false,
                        resolvedFileName: hashedFileName,
                    };
                }
            };
            const getDtsSnapshot = (fileName, importAttributes, code) => (ts.ScriptSnapshot.fromString(importablePlugins.generateTypeScriptDefinition(fileName, importAttributes, code)));
            const languageServiceHost = {
                resolveModuleNameLiterals(moduleNames, containingFile, ...rest) {
                    if (!info.languageServiceHost.resolveModuleNameLiterals) {
                        return undefined;
                    }
                    const resolvedModules = info.languageServiceHost.resolveModuleNameLiterals(moduleNames, containingFile, ...rest);
                    const moduleResolver = createModuleResolver(containingFile);
                    return moduleNames.map((module, index) => {
                        try {
                            const resolvedModule = moduleResolver(module.text, Object(module.parent).assertClause);
                            if (resolvedModule) {
                                return {
                                    resolvedModule
                                };
                            }
                        }
                        catch {
                            // do nothing and continue
                        }
                        return resolvedModules[index];
                    });
                },
                getScriptSnapshot(fileName) {
                    const snapshot = info.languageServiceHost.getScriptSnapshot(fileName);
                    const code = snapshot !== undefined && 'text' in snapshot ? snapshot.text : undefined;
                    if (typeof code !== 'string')
                        return snapshot;
                    if (/\.[cm]?[jt]s$/.test(fileName))
                        return snapshot;
                    if (!importablePlugins.testImportModuleSpecifier(fileName))
                        return snapshot;
                    if (!(fileName in assertionMap))
                        return snapshot;
                    const { resolvedFileName, importAttributes } = assertionMap[fileName];
                    return getDtsSnapshot(resolvedFileName, importAttributes, code);
                },
            };
            return ts.createLanguageService(new Proxy(info.languageServiceHost, {
                get(target, key) {
                    return (key in languageServiceHost
                        ? languageServiceHost[key]
                        : target[key]);
                },
            }));
        },
        getExternalFiles(project) {
            return project.getFileNames().filter(fileName => importablePlugins.testImportModuleSpecifier(fileName));
        },
    };
});

export { importableTsconfig as default };
//# sourceMappingURL=importable-tsconfig.mjs.map
